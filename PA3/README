README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		  -> [course dir]/src/PA3/Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [course dir]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [course dir]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [course dir]/src/PA3/dumptype.cc
 handle_flags.c           -> [course dir]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [course dir]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [course dir]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [course dir]/src/PA3/tokens-lex.cc
 tree.cc		  -> [course dir]/src/PA3/tree.cc
 utilities.cc		  -> [course dir]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% gmake parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% gmake dotest

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	To turnin your work type:

	% gmake submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.y, good.cl, bad.cl,
	good.output, bad.output, and README. Don't forget to edit the
	README file to include your write-up, and to write your own test
	cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	If you change architectures you must issue

	% gmake clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

In this project we were tasked with designing the syntactic parser for the Cool language, the file cool.y contains the definitions and rules that we created for the language, our decisions were mainly based around information's we found regarding the language and its compositions on the Cool Manual, Cool Tour and the Bison Documentation. 

The terminals and non-terminals that we are using are listed between lines 70 and 83. They describe the tokens listed in the Union section, line 26, we also decided to add a definition for the various variables that may appear during the LET command. 

The precedences for the operators were defined based on page 17 of Cool Manual, which states that binary operators are LEFT associative, ASSING is right associative, and the three comparison operators '<', '=' and '<=' are non-associative. 

The rules and derivations were created following page 16 on the Cool Manual, which describes the syntax tree of the language, we reproduced these rules in Bison. 
We decided to divide certain rules that had optional parameters into two instances, one that didn't receive any optional parameter and another that could receive one or more parameters, using a list. This decision is especially used for the formals, features, expressions, cases and let_variables. 

The expressions of the language also follow the definitions of the Syntax Tree on the Cool Manual, when finding a certain expression, it calls the constructor of that expression written on the cool-tree.aps file, which is then used to create the abstract syntax tree. An in-depth explanation of these constructors as well as each function they describe can be found in the Cool Tour, section 6. Besides the already defined expressions in the tree, we also added an auxiliary expression for the LET command, defined in line X, due to its special behavior of being able to receive multiple instances of variables, which all must be in the same scope. 
 
Finally, we treat the errors defined in the specification of the project by adding a possible error terminal to some rules, which then calls the bison function that parses these errors and keeps the program running. These errors are present in the definitions for Features, Classes and Expressions.  
 
We check whether the classes definitions are correct, so the IDs must be written according to the grammar, the inheritance must be a valid type and it must be closed correctly, features follow a similar rule, where the IDs must be valid and we evaluate the LET variables linkage and the use of expressions that extend their block scope. 

We executed tests for the STACK program we developed in PA1 and for the example codes found in /var/tmp/cool/examples, we also modified the stack program to reproduce and test some errors, these files are listed as stack_studentName_bad.cl, in the bad.cl file we added base error tests especially aimed at the situations listed in the project specification. 

Students:
Rafael Ramos de Andrade
Victor Gabriel Mendes SÃ¼ndermann
